<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Import Source Reflection
stage: 1
contributors: Luca Casonato, Guy Bedford, Nicol√≤ Ribaudo
</pre>

<emu-clause id="sec-ecmascript-language-expressions" number="13">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-import-calls" number="3.10">
    <h1>Import Calls</h1>

    <emu-clause id="sec-import-call-runtime-semantics-evaluation" type="sdo">
      <h1>Runtime Semantics: Evaluation</h1>

      <emu-grammar>ImportCall : `import` `(` AssignmentExpression `)`</emu-grammar>
      <emu-alg>
        1. <del>Let _referrer_ be GetActiveScriptOrModule().</del>
        1. <del>If _referrer_ is *null*, set _referrer_ to the current Realm Record.</del>
        1. <del>Let _argRef_ be ? Evaluation of |AssignmentExpression|.</del>
        1. <del>Let _specifier_ be ? GetValue(_argRef_).</del>
        1. <del>Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).</del>
        1. <del>Let _specifierString_ be Completion(ToString(_specifier_)).</del>
        1. <del>IfAbruptRejectPromise(_specifierString_, _promiseCapability_).</del>
        1. <del>Perform HostLoadImportedModule(_referrer_, _specifierString_, ~empty~, _promiseCapability_).</del>
        1. <del>Return _promiseCapability_.[[Promise]].</del>
        1. <ins>Let _specifierRef_ be the result of evaluating |AssignmentExpression|.</ins>
        1. <ins>Let _specifier_ be ? GetValue(_specifierRef_).</ins>
        1. <ins>Return EvaluateImportCall(_specifier_, *undefined*).</ins>
      </emu-alg>

      <emu-grammar><ins>ImportCall : `import` `(` AssignmentExpression `,` AssignmentExpression `)`</ins></emu-grammar>
      <emu-alg>
        1. <ins>Let _specifierRef_ be the result of evaluating the first |AssignmentExpression|.</ins>
        1. <ins>Let _specifier_ be ? GetValue(_specifierRef_).</ins>
        1. <ins>Let _optionsRef_ be the result of evaluating the second |AssignmentExpression|.</ins>
        1. <ins>Let _options_ be ? GetValue(_optionsRef_).</ins>
        1. <ins>Return EvaluateImportCall(_specifier_, _options_).</ins>
      </emu-alg>

      <emu-clause id="sec-evaluate-import-call" type="abstract operation">
        <h1><ins>EvaluateImportCall ( _specifier_ , _options_ )</ins></h1>
        <dl class="header"></dl>
        <emu-alg>
          1. Let _referrer_ be GetActiveScriptOrModule().
          1. If _referrer_ is *null*, set _referrer_ to the current Realm Record.
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _specifierString_ be Completion(ToString(_specifier_)).
          1. IfAbruptRejectPromise(_specifierString_, _promiseCapability_).
          1. Let _sourcePhase_ be *false*.
          1. If _options_ is not *undefined*, then
            1. If Type(_options_) is not Object,
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).
              1. Return _promiseCapability_.[[Promise]].
            1. Let _phaseOption_ be Get(_options_, *"phase"*).
            1. IfAbruptRejectPromise(_phaseOption_, _promiseCapability_).
            1. If _phaseOption_ is not *undefined*,
              1. If Type(_phaseOption_) is not *"source"*, then
                1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).
                1. Return _promiseCapability_.[[Promise]].
              1. Set _sourcePhase_ to *true*.
          1. Let _state_ be the DynamicImportState Record { [[PromiseCapability]]: _promiseCapability_, [[SourcePhase]]: _sourcePhase_ }.
          1. Perform HostLoadImportedModule(_referrer_, _specifierString_, ~empty~, _state_).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>

      <p><ins>A <dfn id="dynamicimportstate-record" variants="DynamicImportState Records">DynamicImportState Record</dfn> is a Record that contains information about the loading process of a module graph. It's used to continue loading after a call to HostLoadImportedModule. Each DynamicImportState Record has the fields defined in <emu-xref href="#table-dynamicimportstate-record-fields"></emu-xref>:</ins></p>
      <emu-table id="table-dynamicimportstate-record-fields" caption="DynamicImportState Record Fields">
        <table>
          <tr>
            <th>
              Field Name
            </th>
            <th>
              Value Type
            </th>
            <th>
              Meaning
            </th>
          </tr>
          <tr>
            <td>
              <ins>[[PromiseCapability]]</ins>
            </td>
            <td>
              <ins>a PromiseCapability Record</ins>
            </td>
            <td>
              <ins>The promise to resolve when the dynamic import finishes.</ins>
            </td>
          </tr>
          <tr>
            <td>
              <ins>[[SourcePhase]]</ins>
            </td>
            <td>
              <ins>a Boolean</ins>
            </td>
            <td>
              <ins>It is true if the <code>phase: "source"</code> option was specified.</ins>
            </td>
          </tr>
        </table>
      </emu-table>

      <emu-clause id="sec-ContinueDynamicImport" type="abstract operation">
        <h1>
          ContinueDynamicImport (
            <del>_promiseCapability_: a PromiseCapability Record,</del>
            <ins>_state_: a DynamicImportState Record,</ins>
            _moduleCompletion_: either a normal completion containing a Module Record or a throw completion,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It completes the process of a dynamic import originally started by an <emu-xref href="#sec-import-calls">`import()`</emu-xref> call, resolving or rejecting the promise returned by that call as appropriate.</dd>
        </dl>
        <emu-alg>
          1. <ins>Let _promiseCapability_ be _state_.[[PromiseCapability]].</ins>
          1. If _moduleCompletion_ is an abrupt completion, then
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _moduleCompletion_.[[Value]] &raquo;).
            1. Return ~unused~.
          1. Let _module_ be _moduleCompletion_.[[Value]].
          1. <ins>If _state_.[[SourcePhase]] is *true*, then</ins>
            1. <ins>Let _moduleSourceObject_ be _module_.[[ModuleSourceObject]].</ins>
            1. <ins>If _moduleSourceObject_ is *null*, then</ins>
              1. <ins>Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).</ins>
              1. <ins>Return ~unused~.</ins>
            1. <ins>Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _moduleSourceObject_ &raquo;).</ins>
            1. <ins>Return ~unused~.</ins>
          1. Let _loadPromise_ be _module_.LoadRequestedModules().
          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _promiseCapability_ and performs the following steps when called:
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _reason_ &raquo;).
            1. Return ~unused~.
          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, *""*, &laquo; &raquo;).
          1. Let _linkAndEvaluateClosure_ be a new Abstract Closure with no parameters that captures _module_, _promiseCapability_, and _onRejected_ and performs the following steps when called:
            1. Let _link_ be Completion(_module_.Link()).
            1. If _link_ is an abrupt completion, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _link_.[[Value]] &raquo;).
              1. Return ~unused~.
            1. Let _evaluatePromise_ be _module_.Evaluate().
            1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_ and _promiseCapability_ and performs the following steps when called:
              1. Let _namespace_ be GetModuleNamespace(_module_).
              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _namespace_ &raquo;).
              1. Return ~unused~.
            1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, *""*, 0, &laquo; &raquo;).
            1. Perform PerformPromiseThen(_evaluatePromise_, _onFulfilled_, _onRejected_).
          1. Let _linkAndEvaluate_ be CreateBuiltinFunction(_linkAndEvaluateClosure_, *""*, 0, &laquo; &raquo;).
          1. Perform PerformPromiseThen(_loadPromise_, _linkAndEvaluate_, _onRejected_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules" number="16">
  <h1>ECMAScript Language: Scripts and Modules</h1>

  <emu-clause id="sec-modules">
    <h1>Modules</h1>

    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>

      <emu-clause id="sec-static-semantics-modulerequests" type="sdo">
        <h1>
          Static Semantics: ModuleRequests (
            <ins>optional _recursiveOnly_: a Boolean</ins>
          ): a List of Strings
        </h1>
        <dl class="header">
        </dl>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItem</emu-grammar>
        <emu-alg>
          1. Return ModuleRequests of |ModuleItem|.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _moduleNames_ be ModuleRequests of |ModuleItemList|.
          1. Let _additionalNames_ be ModuleRequests of |ModuleItem|.
          1. Append to _moduleNames_ each element of _additionalNames_ that is not already an element of _moduleNames_.
          1. Return _moduleNames_.
        </emu-alg>
        <emu-grammar>ModuleItem : StatementListItem</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause `;`</emu-grammar>
        <emu-alg>
          1. Return ModuleRequests of |FromClause|.
        </emu-alg>
        <emu-grammar><ins>ImportDeclaration : `import` `module` ImportedBinding FromClause `;`</ins></emu-grammar>
        <emu-alg>
          1. <ins>If _recursiveOnly_ is *true*, return a new empty List.</ins>
          1. <ins>Return ModuleRequests of |FromClause|.</ins>
        </emu-alg>
        <emu-grammar>ModuleSpecifier : StringLiteral</emu-grammar>
        <emu-alg>
          1. Return a List whose sole element is the SV of |StringLiteral|.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` ExportFromClause FromClause `;`
        </emu-grammar>
        <emu-alg>
          1. Return the ModuleRequests of |FromClause|.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` NamedExports `;`
            `export` VariableStatement
            `export` Declaration
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-abstract-module-records">
        <h1>Abstract Module Records</h1>
        <p>A <dfn variants="Module Records">Module Record</dfn> encapsulates structural information about the imports and exports of a single module. This information is used to link the imports and exports of sets of connected modules. A Module Record includes four fields that are only used when evaluating a module.</p>
        <p>For specification purposes Module Record values are values of the Record specification type and can be thought of as existing in a simple object-oriented hierarchy where Module Record is an abstract class with both abstract and concrete subclasses. This specification defines the abstract subclass named Cyclic Module Record and its concrete subclass named Source Text Module Record. Other specifications and implementations may define additional Module Record subclasses corresponding to alternative module definition facilities that they defined.</p>
        <p>Module Record defines the fields listed in <emu-xref href="#table-module-record-fields"></emu-xref>. All Module Definition subclasses include at least those fields. Module Record also defines the abstract method list in <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref>. All Module definition subclasses must provide concrete implementations of these abstract methods.</p>
        <emu-table id="table-module-record-fields" caption="Module Record Fields" oldids="table-36">
          <table>
            <thead>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
            </thead>
            <tr>
              <td>
                [[Realm]]
              </td>
              <td>
                a Realm Record
              </td>
              <td>
                The Realm within which this module was created.
              </td>
            </tr>
            <tr>
              <td>
                [[Environment]]
              </td>
              <td>
                a Module Environment Record or ~empty~
              </td>
              <td>
                The Environment Record containing the top level bindings for this module. This field is set when the module is linked.
              </td>
            </tr>
            <tr>
              <td>
                [[Namespace]]
              </td>
              <td>
                an Object or ~empty~
              </td>
              <td>
                The Module Namespace Object (<emu-xref href="#sec-module-namespace-objects"></emu-xref>) if one has been created for this module.
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[ModuleSourceObject]]</ins>
              </td>
              <td>
                <ins>an Object or *null* (defaults to *null*)</ins>
              </td>
              <td>
                <ins>The AbstractModuleSource Object subclass corresponding to this source Module Record's source phase (<emu-xref href="#sec-modulesource-objects"></emu-xref>).</ins>
              </td>
            </tr>
            <tr>
              <td>
                [[HostDefined]]
              </td>
              <td>
                anything (default value is *undefined*)
              </td>
              <td>
                Field reserved for use by host environments that need to associate additional information with a module.
              </td>
            </tr>
          </table>
        </emu-table>
      </emu-clause>

      <emu-clause id="sec-cyclic-module-records">
        <h1>Cyclic Module Records</h1>

        <p>A <dfn id="cyclic-module-record" variants="Cyclic Module Records">Cyclic Module Record</dfn> is used to represent information about a module that can participate in dependency cycles with other modules that are subclasses of the Cyclic Module Record type. Module Records that are not subclasses of the Cyclic Module Record type must not participate in dependency cycles with Source Text Module Records.</p>
        <p>In addition to the fields defined in <emu-xref href="#table-module-record-fields"></emu-xref> Cyclic Module Records have the additional fields listed in <emu-xref href="#table-cyclic-module-fields"></emu-xref></p>
        <emu-table id="table-cyclic-module-fields" caption="Additional Fields of Cyclic Module Records">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[Status]]
              </td>
              <td>
                ~unlinked~, ~linking~, ~linked~, ~evaluating~, ~evaluating-async~, or ~evaluated~
              </td>
              <td>
                Initially ~unlinked~. Transitions to ~linking~, ~linked~, ~evaluating~, possibly ~evaluating-async~, ~evaluated~ (in that order) as the module progresses throughout its lifecycle. ~evaluating-async~ indicates this module is queued to execute on completion of its asynchronous dependencies or it is a module whose [[HasTLA]] field is *true* that has been executed and is pending top-level completion.
              </td>
            </tr>
            <tr>
              <td>
                [[EvaluationError]]
              </td>
              <td>
                a throw completion or ~empty~
              </td>
              <td>
                A throw completion representing the exception that occurred during evaluation. *undefined* if no exception occurred or if [[Status]] is not ~evaluated~.
              </td>
            </tr>
            <tr>
              <td>
                [[DFSIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                Auxiliary field used during Link and Evaluate only. If [[Status]] is ~linking~ or ~evaluating~, this non-negative number records the point at which the module was first visited during the depth-first traversal of the dependency graph.
              </td>
            </tr>
            <tr>
              <td>
                [[DFSAncestorIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                Auxiliary field used during Link and Evaluate only. If [[Status]] is ~linking~ or ~evaluating~, this is either the module's own [[DFSIndex]] or that of an "earlier" module in the same strongly connected component.
              </td>
            </tr>
            <tr>
              <td>
                [[RequestedModules]]
              </td>
              <td>
                a List of Strings
              </td>
              <td>
                A List of all the |ModuleSpecifier| strings used by the module represented by this record to request the importation of a module. The List is source text occurrence ordered.
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[RequestedSourcePhasesOnly]]</ins>
              </td>
              <td>
                <ins>a List of Strings</ins>
              </td>
              <td>
                <ins>a List of all the |ModuleSpecifier| strings that have been imported exclusively using <code>import module</code> declarations, and thus that shouldn't be recursively loaded.</ins>

                <emu-note>
                  <p>For example, given this code:</p>
                  <pre><code class="javascript">import "A";</code><code class="javascript">import module A from "A";</code><code class="javascript">import module B from "B";</code></pre>
                  <p>[[RequestedSourcePhasesOnly]] is ¬´ `"C"` ¬ª.</p>
                </emu-note>
              </td>
            </tr>
            <tr>
              <td>
                [[CycleRoot]]
              </td>
              <td>
                a Cyclic Module Record or ~empty~
              </td>
              <td>
                The first visited module of the cycle, the root DFS ancestor of the strongly connected component. For a module not in a cycle this would be the module itself. Once Evaluate has completed, a module's [[DFSAncestorIndex]] is equal to the [[DFSIndex]] of its [[CycleRoot]].
              </td>
            </tr>
            <tr>
              <td>
                [[HasTLA]]
              </td>
              <td>
                a Boolean
              </td>
              <td>
                Whether this module is individually asynchronous (for example, if it's a Source Text Module Record containing a top-level await). Having an asynchronous dependency does not mean this field is *true*. This field must not change after the module is parsed.
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncEvaluation]]
              </td>
              <td>
                a Boolean
              </td>
              <td>
                Whether this module is either itself asynchronous or has an asynchronous dependency. Note: The order in which this field is set is used to order queued executions, see <emu-xref href="#sec-async-module-execution-fulfilled"></emu-xref>.
              </td>
            </tr>
            <tr>
              <td>
                [[TopLevelCapability]]
              </td>
              <td>
                a PromiseCapability Record or ~empty~
              </td>
              <td>
                If this module is the [[CycleRoot]] of some cycle, and Evaluate() was called on some module in that cycle, this field contains the PromiseCapability Record for that entire evaluation. It is used to settle the Promise object that is returned from the Evaluate() abstract method. This field will be ~empty~ for any dependencies of that module, unless a top-level Evaluate() has been initiated for some of those dependencies.
              </td>
            </tr>
            <tr>
              <td>
                [[AsyncParentModules]]
              </td>
              <td>
                a List of Cyclic Module Records
              </td>
              <td>
                If this module or a dependency has [[HasTLA]] *true*, and execution is in progress, this tracks the parent importers of this module for the top-level execution job. These parent modules will not start executing before this module has successfully completed execution.
              </td>
            </tr>
            <tr>
              <td>
                [[PendingAsyncDependencies]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td>
                If this module has any asynchronous dependencies, this tracks the number of asynchronous dependency modules remaining to execute for this module. A module with asynchronous dependencies will be executed when this field reaches 0 and there are no execution errors.
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-LoadRequestedModules" type="concrete method">
          <h1>
            LoadRequestedModules (
              optional _hostDefined_: anything,
            ): a Promise object
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>
          </dl>

          <emu-clause id="sec-InnerModuleLoading" type="abstract operation">
            <h1>
              InnerModuleLoading (
                _state_: a GraphLoadingState Record,
                _module_: a Module Record,
                <ins>optional _referrer_: a Cyclic Module Record,</ins>
                <ins>optional _specifier_: a String,</ins>
              ): ~unused~
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by LoadRequestedModules to recursively perform the actual loading process for _module_'s dependency graph.</dd>
            </dl>

            <emu-alg>
              1. Assert: _state_.[[IsLoading]] is *true*.
              1. <ins>Let _importOnlyAsPhase_ be *false*.</ins>
              1. <ins>If _referrer_ has been specified, then</ins>
                1. <ins>Assert: _specifier_ has been specified.</ins>
                1. <ins>If _referrer_.[[RequestedSourcePhasesOnly]] contains _specifier_, set _importOnlyAsPhase_ to *true*.</ins>
              1. If <ins>_importOnlyAsPhase_ is *false*,</ins> _module_ is a Cyclic Module Record, _module_.[[Status]] is ~new~, and _state_.[[Visited]] does not contain _module_, then
                1. Append _module_ to _state_.[[Visited]].
                1. Let _requestedModulesCount_ be the length of _module_.[[RequestedModules]].
                1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] + _requestedModulesCount_.
                1. For each String _required_ of _module_.[[RequestedModules]], do
                  1. If _module_.[[LoadedModules]] contains a Record _record_ whose [[Specifier]] is _required_, then
                    1. Perform InnerModuleLoading(_state_, _record_.[[Module]], <ins>_module_, _required_</ins>).
                  1. Else,
                    1. Perform HostLoadImportedModule(_module_, _required_, _state_.[[HostDefined]], _state_).
                    1. NOTE: HostLoadImportedModule will call FinishLoadingImportedModule, which re-enters the graph loading process through ContinueModuleLoading.
                  1. If _state_.[[IsLoading]] is *false*, return ~unused~.
              1. Assert: _state_.[[PendingModulesCount]] &ge; 1.
              1. Set _state_.[[PendingModulesCount]] to _state_.[[PendingModulesCount]] - 1.
              1. If _state_.[[PendingModulesCount]] = 0, then
                1. Set _state_.[[IsLoading]] to *false*.
                1. For each Cyclic Module Record _loaded_ in _state_.[[Visited]], do
                  1. If _loaded_.[[Status]] is ~new~, set _loaded_.[[Status]] to ~unlinked~.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, &laquo; *undefined* &raquo;).
              1. Return ~unused~.
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-ContinueModuleLoading" type="abstract operation">
            <h1>
              ContinueModuleLoading (
                _state_: a GraphLoadingState Record,
                <ins>_referrer_: a Cyclic Module Record,</ins>
                <ins>_specifier_: a String,</ins>
                _moduleCompletion_: either a normal completion containing a Module Record or a throw completion,
              ): ~unused~
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used to re-enter the loading process after a call to HostLoadImportedModule.</dd>
            </dl>

            <emu-alg>
              1. If _state_.[[IsLoading]] is *false*, return ~unused~.
              1. If _moduleCompletion_ is a normal completion, then
                1. Perform InnerModuleLoading(_state_, _moduleCompletion_.[[Value]], <ins>_referrer_, _specifier_</ins>).
              1. Else,
                1. Set _state_.[[IsLoading]] to *false*.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, &laquo; _moduleCompletion_.[[Value]] &raquo;).
              1. Return ~unused~.
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-source-text-module-records">
        <h1>Source Text Module Records</h1>

        <p>An <dfn id="importentry-record" variants="ImportEntry Records">ImportEntry Record</dfn> is a Record that digests information about a single declarative import. Each ImportEntry Record has the fields defined in <emu-xref href="#table-importentry-record-fields"></emu-xref>:</p>
        <emu-table id="table-importentry-record-fields" caption="ImportEntry Record Fields" oldids="table-39">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[ModuleRequest]]
              </td>
              <td>
                a String
              </td>
              <td>
                String value of the |ModuleSpecifier| of the |ImportDeclaration|.
              </td>
            </tr>
            <tr>
              <td>
                [[ImportName]]
              </td>
              <td>
                a String or ~namespace-object~<ins> or ~module~</ins>
              </td>
              <td>
                The name under which the desired binding is exported by the module identified by [[ModuleRequest]]. The value ~namespace-object~ indicates that the import request is for the target module's namespace object. <ins>The value ~module~ indicates that the import request is for a module import phaseion.</ins>
              </td>
            </tr>
            <tr>
              <td>
                [[LocalName]]
              </td>
              <td>
                a String
              </td>
              <td>
                The name that is used to locally access the imported value from within the importing module.
              </td>
            </tr>
          </table>
        </emu-table>


        <emu-clause id="sec-parsemodule" type="abstract operation">
          <h1>
            ParseModule (
              _sourceText_: ECMAScript source text,
              _realm_: a Realm Record,
              _hostDefined_: anything,
            ): a Source Text Module Record or a non-empty List of *SyntaxError* objects
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It creates a Source Text Module Record based upon the result of parsing _sourceText_ as a |Module|.</dd>
          </dl>
          <emu-alg>
            1. Let _body_ be ParseText(_sourceText_, |Module|).
            1. If _body_ is a List of errors, return _body_.
            1. Let _requestedModules_ be the ModuleRequests of _body_.
            1. <ins>Let _recursiveRequestedModules_ be the ModuleRequests of _body_ with argument *true*</ins>.
            1. <ins>Let _requestedSourcePhasesOnly_ be a list containing the elements of _requestedModules_ that are not elements of _recursiveRequestedModules_
            1. Let _importEntries_ be ImportEntries of _body_.
            1. Let _importedBoundNames_ be ImportedLocalNames(_importEntries_).
            1. Let _indirectExportEntries_ be a new empty List.
            1. Let _localExportEntries_ be a new empty List.
            1. Let _starExportEntries_ be a new empty List.
            1. Let _exportEntries_ be ExportEntries of _body_.
            1. For each ExportEntry Record _ee_ of _exportEntries_, do
              1. If _ee_.[[ModuleRequest]] is *null*, then
                1. If _ee_.[[LocalName]] is not an element of _importedBoundNames_, then
                  1. Append _ee_ to _localExportEntries_.
                1. Else,
                  1. Let _ie_ be the element of _importEntries_ whose [[LocalName]] is the same as _ee_.[[LocalName]].
                  1. If _ie_.[[ImportName]] is ~namespace-object~, then
                    1. NOTE: This is a re-export of an imported module namespace object.
                    1. Append _ee_ to _localExportEntries_.
                  1. Else,
                    1. NOTE: This is a re-export of a single name.
                    1. Append the ExportEntry Record { [[ModuleRequest]]: _ie_.[[ModuleRequest]], [[ImportName]]: _ie_.[[ImportName]], [[LocalName]]: *null*, [[ExportName]]: _ee_.[[ExportName]] } to _indirectExportEntries_.
              1. Else if _ee_.[[ImportName]] is ~all-but-default~, then
                1. Assert: _ee_.[[ExportName]] is *null*.
                1. Append _ee_ to _starExportEntries_.
              1. Else,
                1. Append _ee_ to _indirectExportEntries_.
            1. Let _async_ be _body_ Contains `await`.
            1. Return Source Text Module Record { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[CycleRoot]]: ~empty~, [[HasTLA]]: _async_, [[AsyncEvaluation]]: *false*, [[TopLevelCapability]]: ~empty~, [[AsyncParentModules]]: &laquo; &raquo;, [[PendingAsyncDependencies]]: ~empty~, [[Status]]: ~new~, [[EvaluationError]]: ~empty~, [[HostDefined]]: _hostDefined_, [[ECMAScriptCode]]: _body_, [[Context]]: ~empty~, [[ImportMeta]]: ~empty~, [[RequestedModules]]: _requestedModules_, <ins>[[RequestedSourcePhasesOnly]]: _requestedSourcePhasesOnly_,</ins> [[LoadedModules]]: a new empty List, [[ImportEntries]]: _importEntries_, [[LocalExportEntries]]: _localExportEntries_, [[IndirectExportEntries]]: _indirectExportEntries_, [[StarExportEntries]]: _starExportEntries_, [[DFSIndex]]: ~empty~, [[DFSAncestorIndex]]: ~empty~, <ins>[[ModuleSourceObject]]: *null*</ins> }.
          </emu-alg>

          <emu-note type="editor">
            <a href="https://tc39.es/proposal-compartments/0-module-and-module-source.html">Layer 0 of the Compartments proposal</a> defines ModuleSource objects, which would be used here as the [[ModuleSourceObject]] of Source Text Module Records.
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-initialize-environment" type="concrete method">
          <h1>InitializeEnvironment ( ): either a normal completion containing ~unused~ or a throw completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>
          </dl>

          <emu-alg>
            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do
              1. Let _resolution_ be _module_.ResolveExport(_e_.[[ExportName]]).
              1. If _resolution_ is *null* or ~ambiguous~, throw a *SyntaxError* exception.
              1. Assert: _resolution_ is a ResolvedBinding Record.
            1. Assert: All named exports from _module_ are resolvable.
            1. Let _realm_ be _module_.[[Realm]].
            1. Assert: _realm_ is not *undefined*.
            1. Let _env_ be NewModuleEnvironment(_realm_.[[GlobalEnv]]).
            1. Set _module_.[[Environment]] to _env_.
            1. For each ImportEntry Record _in_ of _module_.[[ImportEntries]], do
              1. Let _importedModule_ be GetImportedModule(_module_, _in_.[[ModuleRequest]]).
              1. If _in_.[[ImportName]] is ~namespace-object~, then
                1. Let _namespace_ be GetModuleNamespace(_importedModule_).
                1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).
              1. <ins>Else if _in_.[[ImportName]] is ~module~, then</ins>
                1. <ins>Let _moduleSourceObject_ be _importedModule_.[[ModuleSourceObject]].</ins>
                1. <ins>If _moduleSourceObject_ is *null*, throw a *TypeError* exception.</ins>
                1. <ins>Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).</ins>
                1. <ins>Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _moduleSourceObject_).</ins>
              1. Else,
                1. Let _resolution_ be _importedModule_.ResolveExport(_in_.[[ImportName]]).
                1. If _resolution_ is *null* or ~ambiguous~, throw a *SyntaxError* exception.
                1. If _resolution_.[[BindingName]] is ~namespace~, then
                  1. Let _namespace_ be GetModuleNamespace(_resolution_.[[Module]]).
                  1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                  1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).
                1. Else,
                  1. Perform _env_.CreateImportBinding(_in_.[[LocalName]], _resolution_.[[Module]], _resolution_.[[BindingName]]).
            1. Let _moduleContext_ be a new ECMAScript code execution context.
            1. Set the Function of _moduleContext_ to *null*.
            1. Assert: _module_.[[Realm]] is not *undefined*.
            1. Set the Realm of _moduleContext_ to _module_.[[Realm]].
            1. Set the ScriptOrModule of _moduleContext_ to _module_.
            1. Set the VariableEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the LexicalEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the PrivateEnvironment of _moduleContext_ to *null*.
            1. Set _module_.[[Context]] to _moduleContext_.
            1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.
            1. Let _code_ be _module_.[[ECMAScriptCode]].
            1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.
            1. Let _declaredVarNames_ be a new empty List.
            1. For each element _d_ of _varDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If _dn_ is not an element of _declaredVarNames_, then
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                  1. Perform ! _env_.InitializeBinding(_dn_, *undefined*).
                  1. Append _dn_ to _declaredVarNames_.
            1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.
            1. Let _privateEnv_ be *null*.
            1. For each element _d_ of _lexDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If IsConstantDeclaration of _d_ is *true*, then
                  1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).
                1. Else,
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                1. If _d_ is a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then
                  1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.
                  1. Perform ! _env_.InitializeBinding(_dn_, _fo_).
            1. Remove _moduleContext_ from the execution context stack.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-FinishLoadingImportedModule" type="abstract operation" number="8">
        <h1>
          FinishLoadingImportedModule (
            _referrer_: a Script Record, a Cyclic Module Record, or a Realm Record,
            _specifier_: a String,
            _state_: a GraphLoadingState Record or a DynamicImportState Record,
            _result_: either a normal completion containing a Module Record or a throw completion,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. If _result_ is a normal completion, then
            1. If _referrer_.[[LoadedModules]] contains a Record _record_ such that _record_.[[Specifier]] is _specifier_, then
              1. Assert: _record_.[[Module]] is _result_.[[Value]].
            1. Else, append the Record { [[Specifier]]: _specifier_, [[Module]]: _result_.[[Value]] } to _referrer_.[[LoadedModules]].
          1. If _state_ is a GraphLoadingState Record, then
            1. Perform ContinueModuleLoading(_state_, <ins>_referrer_, _specifier_,</ins> _result_).
          1. Else,
            1. Perform ContinueDynamicImport(_state_, _result_).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-imports">
    <h1>Imports</h1>
    <h2>Syntax</h2>
    <emu-grammar type="definition">
      ImportDeclaration :
        `import` ImportClause FromClause `;`
        `import` ModuleSpecifier `;`
        <ins>`import` `module` ImportedBinding FromClause `;`</ins>

      ImportClause :
        ImportedDefaultBinding
        NameSpaceImport
        NamedImports
        ImportedDefaultBinding `,` NameSpaceImport
        ImportedDefaultBinding `,` NamedImports
  
      ImportedDefaultBinding :
        ImportedBinding
  
      NameSpaceImport :
        `*` `as` ImportedBinding
  
      NamedImports :
        `{` `}`
        `{` ImportsList `}`
        `{` ImportsList `,` `}`
  
      FromClause :
        `from` ModuleSpecifier
  
      ImportsList :
        ImportSpecifier
        ImportsList `,` ImportSpecifier
  
      ImportSpecifier :
        ImportedBinding
        ModuleExportName `as` ImportedBinding
  
      ModuleSpecifier :
        StringLiteral
  
      ImportedBinding :
        BindingIdentifier[~Yield, +Await]
    </emu-grammar>
  
    <emu-clause id="sec-static-semantics-importentries" oldids="sec-module-semantics-static-semantics-importentries,sec-imports-static-semantics-importentries" type="syntax-directed operation">
      <h1>Static Semantics: ImportEntries ( ): a List of ImportEntry Records</h1>
      <dl class="header">
      </dl>
      <emu-grammar>Module : [empty]</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
      <emu-alg>
        1. Let _entries1_ be ImportEntries of |ModuleItemList|.
        1. Let _entries2_ be ImportEntries of |ModuleItem|.
        1. Return the list-concatenation of _entries1_ and _entries2_.
      </emu-alg>
      <emu-grammar>
        ModuleItem :
          ExportDeclaration
          StatementListItem
      </emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ImportClause FromClause `;`</emu-grammar>
      <emu-alg>
        1. Let _module_ be the sole element of ModuleRequests of |FromClause|.
        1. Return ImportEntriesForModule of |ImportClause| with argument _module_.
      </emu-alg>
      <emu-grammar>ImportDeclaration : `import` ModuleSpecifier `;`</emu-grammar>
      <emu-alg>
        1. Return a new empty List.
      </emu-alg>
      <emu-grammar><ins>ImportDeclaration : `import` `module` ImportedBinding FromClause `;`</ins></emu-grammar>
      <emu-alg>
        1. <ins>Let _localName_ be the sole element of BoundNames of |ImportedBinding|.</ins>
        1. <ins>Let _entry_ be the ImportEntry Record { [[ModuleRequest]]: _module_, [[ImportName]]: ~module~, [[LocalName]]: _localName_ }.</ins>
        1. <ins>Return &laquo; _entry_ &raquo;.</ins>
      </emu-alg>
    </emu-clause>
  </emu-clause>
</emu-clause>
<emu-clause id="sec-reflection" number=28>
  <h1>Reflection</h1>
  <emu-clause id="sec-modulesource-objects">
    <h1><ins>ModuleSource Objects</ins></h1>
    <p>Different source record types reflect as different module source class instances in their source phase, which represent a compiled source module which has not yet been linked, instantiated or executed.</p>
    <p>All ModuleSource reflection Objects are subclasses of %AbstractModuleSource% and provide a [[HostSourceMetadata]] internal slot.</p>

    <emu-clause id="sec-%abstractmodulesource%-intrinsic-object">
      <h1>The %AbstractModuleSource% Intrinsic Object</h1>
      <p>The <dfn>%AbstractModuleSource%</dfn> intrinsic object:</p>
      <ul>
        <li>is a constructor function object that all of the _AbstractModuleSource_ constructor objects inherit from.</li>
        <li>along with its corresponding prototype object, provides common properties that are inherited by all _AbstractModuleSource_ constructors and their instances.</li>
        <li>does not have a global name or appear as a property of the global object.</li>
        <li>acts as the abstract superclass of the various _AbstractModuleSource_ constructors.</li>
        <li>will throw an error when invoked, because it is an abstract class constructor. The _AbstractModuleSource_ constructors do not perform a `super` call to it.</li>
      </ul>
 
      <emu-clause id="sec-%abstractmodulesource%">
        <h1>%AbstractModuleSource% ( )</h1>
        <p>This function performs the following steps when called:</p>
        <emu-alg>
          1. Throw a *TypeError* exception.
        </emu-alg>
        <p>The *"length"* property of this function is *+0*<sub>ùîΩ</sub>.</p>
      </emu-clause>

      <emu-note>
        <p>All subclasses of AbstractModuleSource must provide a @@toStringTag property getter performing an instance branding check (see <emu-xref href="#sec-get-modulesource-prototype-@@tostringtag"></emu-xref>).</p>
      </emu-note>
    </emu-clause>

    <emu-clause id="sec-abstract-operations-for-abstractmodulesource-objects">
      <h1>Abstract Operations for AbstractModuleSource Objects</h1>
      <emu-clause id="sec-retrievehostsourcemetadata" type="abstract operation">
        <h1>
          RetrieveHostSourceMetadata (
            _anyModuleSource_: an Object,
          ): anything
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>Used to retrieve the host-defined data from a subclass of %AbstractModuleSource% to populate for a new instance of its module record by the host.</dd>
        </dl>
        <emu-alg>
          1. Assert: _anyModuleSource_ is an instance of a subclass of %AbstractModuleSource%.
          1. Assert: _anyModuleSource_ has a [[HostSourceMetadata]] internal slot.
          1. Return _anyModuleSource_.[[HostSourceMetadata]].
        </emu-alg>
      </emu-clause>
    </emu-clause>

    <emu-clause id="sec-modulesource-constructor">
      <h1>The ModuleSource Constructor</h1>
      <p>The ModuleSource Object AbstractModuleSource subclass represents the source phase of SourceTextModuleRecord.</p>

      <p>The ModuleSource constructor:</p>
      <ul>
        <li>is <dfn>%ModuleSource%</dfn>.</li>
        <li>is the initial value of the *"ModuleSource"* property of the global object.</li>
        <li>is a subclass of `%AbstractModuleSource%`.</li>
      </ul>
    </emu-clause>

    <emu-clause id="sec-properties-of-the-modulesource-prototype-object">
      <h1>Properties of the ModuleSource Prototype Object</h1>
      <p>The <dfn>ModuleSource prototype object</dfn>:</p>
      <ul>
        <li>is <dfn>%ModuleSource.prototype%</dfn>.</li>
        <li>has a [[Prototype]] internal slot whose value is %AbstractModuleSource%.</li>
        <li>has the following properties:</li>
      </ul>

      <emu-clause id="sec-get-modulesource-prototype-@@tostringtag">
        <h1>get ModuleSource Prototype [ @@toStringTag ]</h1>
        <p>`ModuleSource Prototype[@@toStringTag]` is an accessor property whose set accessor function is *undefined*. Its get accessor function performs the following steps when called:</p>
        <emu-alg>
          1. Let _O_ be ? ToObject(*this* value).
          1. Let _proto_ be ? <emu-meta effects="user-code">_O_.[[GetPrototypeOf]]()</emu-meta>.
          1. If _proto_ is not %ModuleSource.prototype%, then
            1. Throw a *TypeError* exception.
          1. Return the String value *"ModuleSource"*.
        </emu-alg>
      </emu-clause>

      <emu-note>
        <p>Only SourceTextModuleRecord module source objects may be represented by a ModuleSource instance and return the *"ModuleSource"* string value for @@toStringTag.</p>
      </emu-note>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-annex id="sec-host-layering-points">
  <h1>Host Layering Points</h1>

  <emu-annex id="sec-host-defined-fields-summary">
    <h1>Host-defined Fields</h1>
    <p>[[HostDefined]] on Realm Records: See <emu-xref href="#table-realm-record-fields"></emu-xref>.</p>
    <p>[[HostDefined]] on Script Records: See <emu-xref href="#table-script-records"></emu-xref>.</p>
    <p>[[HostDefined]] on Module Records: See <emu-xref href="#table-module-record-fields"></emu-xref>.</p>
    <p>[[HostDefined]] on JobCallback Records: See <emu-xref href="#table-jobcallback-records"></emu-xref>.</p>
    <p>[[HostSynchronizesWith]] on Candidate Executions: See <emu-xref href="#table-candidate-execution-records"></emu-xref>.</p>
    <p>[[IsHTMLDDA]]: See <emu-xref href="#sec-IsHTMLDDA-internal-slot"></emu-xref>.</p>
    <p><ins>[[HostSourceMetadata]] on %AbstractModuleSource% subclasses. See <emu-xref href="#sec-retrievehostsourcemetadata"></emu-xref>.</ins></p>
  </emu-annex>
</emu-annex>